# 泛型(generics)

[TOC]

以下文章翻译自golang官方教程[教程: 泛型入门](https://go.dev/doc/tutorial/generics)。

这个教程介绍了go的泛型基础。通过泛型，你可以声明和使用函数或类型，这些函数或类型可以被调用代码提供的任何一组类型所使用。

在本教程中，你将声明两个简单的非泛型函数，然后再单个泛型函数中捕获相同的逻辑。

你将通过以下部分进行：

1. 为你的代码创建一个文件夹。
2. 添加非泛型函数。
3. 添加一个泛型函数来处理多种类型。
4. 调用泛型函数时移除类型声明。
5. 声明类型约束。

注意：有关其它教程，请参见[教程](https://go.dev/doc/tutorial/index.html)

注意：如果你愿意，你可以使用 Go playground 在 "Go dev branch"模式下编辑和运行你的程序。

## 前提条件

- 安装 Go 1.13 或以上。有关安装说明，请参阅[安装 Go](https://go.dev/doc/install)
- 编辑代码的工具。你拥有的任何文本编辑器都能工作。
- 一个命令行。Go可以在 Linux 和 Mac 上使用任何终端，也可以在 Windows 的 PowerShell 和 cmd 上运行。

## 为你的代码创建一个文件夹

要开始，为要编写的代码创建一个文件夹。

1. 打开一个命令行工具并切换到主目录

   在 Linux 或 Mac：

   ```shell
   $ cd
   ```

   在 Windows：

   ```powershell
   C:\> cd %HOMEPATH%
   ```

   本教程的其余部分将使用 $ 作为提示。你使用的命令也适用于 Windows。

2. 在命令行工具下，创建一个名为 generics 的目录。

   ```shell
   $ mkdir generics
   $ cd generics
   ```

3. 创建一个模块来保存代码。

   运行 `go mod init` 命令，为其指定新代码的模块路径。

   ```shell
   $ go mod init example/generics
   go: creating new go.mod: module example/generics
   ```

   注意：在生成环境代码中，你需要指定更符合你需求的具体模块路径。有关更多信息，请参见[管理依赖项](https://go.dev/doc/modules/managing-dependencies)

接下来，你将添加一些简单的代码来处理map。

## 添加非泛型函数

在这一步中，你将添加两个函数，每个函数将一个map的值相加并返回总数。

声明两个函数而不是一个，因为你使用的时两种不同类型的map：一种存储的`int64`值，一种存储`float64`值。

### 写代码

1. 使用你的文本编辑器，创建一个名为main.go的文件。你将在该文件中编写Go代码。

2. 进入 main.go，在文件的最顶端，粘贴以下包声明。

   ```go
   package main
   ```

   一个单独的程序（与库相反）始终位于`main`包中。

3. 在包声明下面，粘贴以下两个函数声明。

   ```go
   // SumInts 将 m 的值相加
   func SumInts(m map[string]int64) int64 {
       var s int64
       for _, v := range m {
           s += v
       }
       return s
   }
   // SumFloats 将 m 的值相加
   func SumFloats(m map[string]float64) float64 {
       var s float64
       for _, v := range m {
           s += v
       }
       return s
   }
   ```

   在此代码中，你：

    - 声明两个将 map 的值相加并返回总和。
      	- `SumFloats`取map中的`string`映射`float64`的值
         	- `SumInts`取map中的`string`映射`int64`的值

4. 在 main.go 的顶端，在包声明的下面，粘贴以下 `main` 函数取初始化两个 maps 并使用它们作为参数去调用你先前步骤写的函数。

   ```go
   func main() {
       // Initialize a map for the integer values
       ints := map[string]int64{
           "first":  34,
           "second": 12,
       }
   
       // Initialize a map for the float values
       floats := map[string]float64{
           "first":  35.98,
           "second": 26.99,
       }
   
       fmt.Printf("Non-Generic Sums: %v and %v\n",
           SumInts(ints),
           SumFloats(floats))
   }
   ```

   在此代码中，你：

   - 初始化 `float64`值的map和`int64`值的map，每个都有两个条目。
   - 调用前面声明的两个函数来查找每个映射值的总和。
   - 打印结果

5. 接近 main.go 的顶端，在包声明的下面，导入你需要的包，以支持你刚刚编写的代码。

   第一行代码应该如下所示：

   ```go
   package main
   
   import "fmt"
   ```

6. Save main.go

### 运行代码

从包含 main.go 的目录命令行去运行代码。

```go
$ go run .
Non-Generic Sums: 46 and 62.97
```

使用泛型，你可以在这里编写一个函数，而不是两个。接下来，你将为包含整数值和浮点值的map添加一个通用函数。

## 添加一个泛型函数来处理多种类型

在本节中，你将添加一个泛型函数，该函数可以接受包含整数或浮点值的map，从而有效地用一个函数替换你编写的两个函数。

为了支持这两种类型的值，单个函数需要一个地方来声明它支持的类型。另一个方面，调用代码需要一种方法来指定它是使用整数还是浮点映射进行调用。

为了支持这一点，你将编写一个函数，在其普通函数参数之外声明类型参数。这些类型参数使得函数具有通用性，使其能够处理不同类型的参数。你将使用类型参数和普通函数参数调用函数。

每个类型参数有一个*类型约束*，它能表现得像类型参数的元类型。每个类型约束指定了允许的类型参数，它能被调用代码用于相应类型参数。

虽然类型参数的约束通常标识一组类型，但在编译时，类型参数代表单个类型——即调用代码提供的类型传参。如果类型传参的类型不被类型参数约束允许，这个代码不能被编译。

请记住，类型参数必须支持泛型对其执行的所有操作。例如，如果函数的代码试图对约束包含数字类型的类型参数执行字符串操作（例如索引），则代码不会被编译。

在即将编写的代码中，你将使用允许整数或浮点类型的约束。

### 写代码

1. 在你先前加的两个函数下面，粘贴下面的泛型代码。

   ```go
   // SumIntsOrFloats 求 map m 值的和。它同时作为支持 int64 和 float64 的 map 值。
   func SumIntsOrFloats[K comparable, V int64 | float64](m map[K]V) V {
       var s V
       for _, v := range m {
           s += v
       }
       return s
   }
   ```

   在此代码中，你：

   - 声明一个`SumIntsOrFloats`函数，该函数有两个类型参数（在方括号中），`K`和`V`，以及一个使用类型参数 m 的参数 map[K]V。这个函数返回类型 `V`的值。
   - 为`K`类型参数指定类型约束`comparable`。专门针对此类情况，`comparable`约束在Go中预先声明，它允许能使用比较运算符 == 和 != 的任何类型。Go 需要 map 的键是可比较的。所以声明`K`作为`comparable`是必须的，这样你就可以使用`K`作为map变量中的键。它还确保调用代码使用允许的map键类型。
   - 为`V`类型参数指定两个类型的联合约束: `int64`和`float64`。使用 `|`指定两种类型的并集，意味着这个约束匀速这两个类型。编译器将允许任何一种类型作为调用代码中的参数。
   - 指定`m`参数的类型为`map[K]V`，其中`K`和`V`是已经为类型参数定义的类型。注意，我们知道 `map[K]V`是一个有效的map类型因为`K`是一个可比较的类型。如果我们没有声明`K`是可比较的，编辑器将拒绝对`map[K]V`的引用。

2. 在 main.go 中，在你已经有的下面代码，粘贴以下代码。

   ```go
   fmt.Println("Generic Sums: %v and %v\n",
               SumIntsOrFloats[string, int64](ints),
               SumIntsOrFloats[string, floats](floats))
   ```

   在这个代码中，你：

   - 调用你声明的泛型函数，传递你创建的每个map。

   - 指定类型传参——方括号中的类型名，以明确在调用的函数中应替换类型参数的类型。

     正如你将在下一节中看到的，你通常可以在函数调用中忽略类型参数。Go通常从代码中推断出它们。

   - 打印函数返回的总和。

### 运行代码

在包含 main.go 目录的命令行中，运行代码:

```go
$ go run .
Non-Generic Sums: 46 and 62.97
Generic Sums: 46 and 62.97
```

要运行你的代码，编译器会在每次调用中用该调用指定的具体类型替换参数。

在调用你编写的泛型函数时，你指定了类型参数，这些参数告诉编译器使用什么类型来代替函数的类型参数。正如你将在下一节中看到的，在许多情况下，你可以忽略这些参数类型，因为编译可以推断它们。

## 调用泛型函数时删除类型参数

在这一节中，

























